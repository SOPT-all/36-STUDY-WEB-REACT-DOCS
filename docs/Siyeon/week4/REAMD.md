## State 업데이트

state 변수를 설정하면 다음 렌더링이 큐에 들어간다.

### React state batches 업데이트

```
import { useState } from 'react';

export default function Counter() {
  const [number, setNumber] = useState(0);

  return (
    <>
      <h1>{number}</h1>
      <button onClick={() => {
        setNumber(number + 1);
        setNumber(number + 1);
        setNumber(number + 1);
      }}>+3</button>
    </>
  )
}

```

위 코드를 보면 `setNumber(number + 1)`을 세 번 호출하기 때문에 +3 버튼을 클릭하면 한번에 3이 증가할 것이라고 생각할 수 있다. 하지만 각 렌더링의 state값은 현재 0으로 고정되어 있다. 따라서 첫 번째 렌더링의 이벤트 핸들러의 `number`값은 `setNumber(1)`을 몇 번 호출하든 항상 0이다.

- React는 state 업데이트를 하기 전에 이벤트 핸들러의 모든 코드가 실행될 때까지 기다린다. 따라서 리렌더링은 모든 `setNumber()`호출이 완료된 이후에만 일어난다.

이렇게 하면 과도한 리렌더링이 발생하지 않고도 여러 컴포넌트에서 나온 다수의 state 변수를 업데이트 할 수 있다. 하지만 이 말은 이벤트 핸들러와 안에 있는 코드가 끝날 때까지 UI가 업데이트되지 않는다는 것과 같은 의미다.

**batching** 이라는 이 동작은 react 앱을 훨씬 빠르게 실행할 수 있게 해준다. 또 일부 변수만 업데이트된 '반쯤 완성된' 혼란스러운 렌더링을 처리하지 않아도 된다.

> 다시 정리, batching이란 React에서 이벤트 핸들러가 실행을 마친 후 state 업데이트를 처리하는 것을 말함.

다음 렌더링 전에 동일한 state 변수를 여러 번 업데이트 하고 싶다면 `setNumber(number + 1)`와 같은 다음 state 값을 전달하는 대신, `setNumber(n => n+1)`처럼 이전 큐의 state를 기반으로 다음 state를 계산하는 함수를 전달할 수 있다. \*단순히 state값을 대체하는 것이 아니라 state 값으로 무엇을 하라고 지시하는 방법!

> 업데이터 함수 인수의 이름은 해당 state 변수의 첫 글자로 지정하는 것이 일반적임

정리하자면,

- 업데이터 함수(`n => n + 1`과 같은)가 큐에 추가된다
- 다른 값(숫자 `5`)은 큐에 "`5`로 바꾸기"를 추가하며, 이미 큐에 대기 중인 항목은 무시한다.
  이벤트 핸들러가 완료되면 React는 리렌더링을 실행한다. 리렌더링하는 동안 React는 큐를 처리한다.

React가 최종 state를 계산하는 데 사용하는 알고리즘 코드 (챌린지 못 풀어냄)

```
export function getFinalState(baseState, queue) {
  let finalState = baseState;

  for (let update of queue) {
    if (typeof update === 'function') {
      // Apply the updater function.
      finalState = update(finalState);
    } else {
      // Replace the next state.
      finalState = update;
    }
  }

  return finalState;
}

```

## 객체 업데이트

state는 객체를 포함한 모든 종류의 자바스크립트 값을 가질 수 있지만 react state가 가진 객체를 직접 변경하면 안된다. 객체를 업데이트하고 싶을 때에는 **새로운 객체를 생성**하거나, **기존 객채의 복사본**을 만들어서 state가 복사본을 사용하도록 해야 한다.

state에 저장한 자바스크립트 객체는 어떤 것이라도 **읽기 전용**인 것처럼 다루어야 한다.

> 주의! 이미 state에 존재하는 객체를 변경할 때만 문제가 된다. 방금 만든 객체를 수정하는 것은 아직 다른 코드가 해당 객체를 참조하지 않기 때문에 괜찮다. => 지역 변경 local mutation이라고 함

`...`객체 전개 구문을 사용하면 모든 프로퍼티를 각각 복사하지 않아도 됨!

- '얕다'는 점을 기억하기. 한 레벨 깊이의 내용만 복사함. 빠르지만 중첩된 프로퍼티를 업데이트하고 싶다면 한 번 이상 사용해야 한다는 뜻.

```
setPerson({
  ...person, // 이전 필드를 복사
  firstName: e.target.value // 새로운 부분은 덮어쓰기
});
```

- 객체들은 중첩되어 있지 않다. 코드에서 중첩되어 나타나도 사실은 가리키고 있는 거지, 실제로 내부에 존재하는 게 아님.

- Immer 라는 라이브러리를 사용하면 편리하고 변경 구문을 사용할 수 있게 해주며 복사본 생성을 도와준다.

> 왜 React에서 state 변경은 권장되지 않나?

- 디버깅
- 최적화
- 새로운 기능
- 요구사항 변화
- 더 간단한 구현

위와 같은 이유로 리액트에서 state 변경을 권장하지 않는다.

\*챌린지 도전하기 다 어려워서 답 보면서 공부함,,,,

## 배열 업데이트

객체와 마찬가지로 state에 저장한 배열을 업데이트하고 싶을 대에는 **새 배열을 생성(혹은 기존 배열의 복사본 생성)**한 뒤, 이 새로운 배열을 state로 두어 업데이트해야 한다.

1. 변경하지 않고 배열 업데이트하기
   React state에서 객체와 마찬가지로 배열은 읽기 전용으로 처리해야 한다.

- 배열 내부의 항목을 재할당해서는 안됨
- `push()`나 `pop()` 같은 함수로 배열을 변경해서는 안됨
  => 배열 업데이트할 때마다 새 배열을 state 설정 함수에 전달해야 한다!
  `filter()`, `map()`같은 함수를 사용하여 원본 배열로부터 새 배열을 만들 수 있다.

* 추가시: `concat` `[...arr]` 제거시: `filter`, `slice` 교체시: `map`

> 주의! `slice`와 `splice`함수는 이름이 비슷하지만 매우 다르다.
> `slice`: 배열 또는 그 일부를 복사할 수 있음
> `splice`: 배열을 변경한다. (항목을 추가하거나 제거)

2. 배열에 항목 추가하기
   `push()`는 배열을 변경하므로 새 항목을 포함하는 새로운 배열을 만드는 `...`배열 전개 구문을 사용하자

3. 배열에서 항목 제거하기
   `filter`함수를 사용하자.

4. 배열 변환하기, 배열 내 항목 교체하기
   `map()`을 사용해서 새로운 배열을 만들 수 있다. 이전 항목의 변경 없이 업데이트된 버전으로 대체할 수 있다.

5. 배열에 항목 삽입하기
   `slice()`함수를 사용하면 배열의 '일부분'을 잘라낼 수 있다.
