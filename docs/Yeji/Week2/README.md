# [Week2] UI 표현하기

## 📓 리스트 렌더링

### 🔑 key의 역할과 규칙

리스트 렌더링에서 각 항목에 key 값을 부여하는 이유는, 리액트가 어떤 항목이 변경/추가/삭제되었는지 정확히 파악하기 위함임.
key는 **형제 노드 사이에서만 고유(unique)**하면 되고, 전체 애플리케이션에서 유일할 필요는 없음.

**가능하면 데이터 고유 ID를 사용해야 함**

- 예: DB에서 가져온 ID, 또는 uuid, crypto.randomUUID() 등

**렌더링 중에 key를 즉석 생성하면 안 됨**

- 매 렌더마다 key가 바뀌면 리액트는 항상 새로운 컴포넌트로 인식함 - 이로 인해 불필요한 마운트/언마운트와 DOM 재생성이 발생할 수 있음

**배열 인덱스를 key로 쓰는 건 지양해야 함**

- 리스트 순서가 바뀌거나 요소가 추가/삭제되면 key가 엉켜서 의도치 않은 리렌더링이 발생함

**key는 props로 전달되지 않음**

- key는 리액트 내부에서만 식별용으로 쓰이기 때문에, props.key로 접근할 수 없음
- key가 필요하다면 직접 props로 전달해줘야 함 (예: <Item id={item.id} />)

## 🫧 컴포넌트를 순수하게 유지하기

리액트에서 컴포넌트는 **입력값(props)**에 따라 **예측 가능한 출력(JSX)**을 내는 순수한 함수처럼 작동해야 함. (== 같은 props를 주면 항상 같은 UI를 반환하고, 외부 상태에 영향을 주지 않아야 함.)

### 순수 함수란

**순수 함수(pure function)**는 아래 두 가지 조건을 만족하는 함수임.

1. 같은 입력 → 항상 같은 출력

   - 외부 상태나 랜덤, 시간 등 입력 외의 어떤 것도 참조하지 않음

2. 사이드 이펙트(side effect)가 없음
   - 외부 상태를 변경하지 않음 (ex: 전역 변수 수정, DOM 조작, 네트워크 요청 등)

### 사이드 이펙트

**사이드 이펙트(side effect)**란, 함수가 실행될 때 컴포넌트 외부의 상태나 환경을 변경하거나 참조하는 모든 행동을 의미함.

ex: 콘솔 출력, DOM 조작, 네트워크 요청, 전역 변수 변경, 로컬 스토리지 접근 등..

순수한 컴포넌트는 예측 가능하고 디버깅이 쉽고, 리렌더링 최적화가 쉬움 (memoization 가능)
동시성 렌더링(concurrent rendering) 환경에서 렌더링 중단, 재시작이 안전하고, 사이드 이펙트를 컴포넌트 안에서 직접 실행하면, 렌더링이 불안정해지고 예상치 못한 버그가 생기기 쉽기 때문에 컴포넌트를 순수하게 유지하는 것이 중요함!

리액트는 사이드 이펙트를 처리하기 위한 **useEffect, useLayoutEffect**를 제공함.
이 훅들은 컴포넌트가 렌더링된 이후에 실행되므로, 렌더링 중에는 안전하게 순수하게 유지할 수 있음.

## 🌳 트리로서의 UI

### 🌐 브라우저 렌더링 과정

**1. HTML 파싱 → DOM 트리 생성**
사용자가 웹사이트에 접속하면, 브라우저는 HTML 파일을 다운로드하여 **파싱(parsing)**을 시작함.
각 HTML 요소를 DOM(Document Object Model) 노드로 변환하고, 이를 계층적으로 연결해 DOM 트리를 만듦.

**2. CSS 파싱 → CSSOM 트리 생성**
HTML 안에 `<link> or <style>` 태그가 있으면 브라우저는 CSS 파일을 추가로 불러와 파싱함.
CSS 규칙을 해석해 CSSOM(CSS Object Model) 트리를 만듦.
이 트리에는 각 요소에 적용될 스타일 정보가 담겨 있음.

**3. 렌더 트리 생성 (DOM + CSSOM)**
DOM과 CSSOM을 기반으로, 실제로 화면에 그려질 요소만 필터링하여 **렌더 트리(Render Tree)**를 생성함.
display: none 등 보이지 않는 요소는 렌더 트리에서 제외됨.

**4. 레이아웃 계산 (Reflow)**
렌더 트리를 바탕으로 각 요소가 어디에 위치할지, 어떤 크기로 그릴지를 계산하는 과정임.
부모-자식 관계를 고려하며 top, left, width, height 등의 값을 결정함.

**5. 페인팅(Painting)**
레이아웃이 완료되면 요소의 색상, 텍스트, 그림자, 테두리 등 시각적인 스타일을 화면에 그림.
이 과정에서 각 요소가 픽셀 단위로 변환됨. 6. 컴포지팅(Compositing)
모든 그래픽 레이어를 **하나의 화면 이미지로 합성(composite)**하는 단계임.
GPU를 사용해 빠르게 최종 이미지를 생성하고 사용자에게 화면을 보여줌.

## 🌳 모듈 의존성 트리

**모듈 의존성 트리(Dependency Tree)**는 하나의 파일(또는 모듈)이 다른 파일(모듈)에 의존하고 있을 때, 이러한 의존 관계를 트리 구조로 시각화한 것을 의미함.
주로 **웹 번들러(Webpack, Vite, Rollup 등)**가 번들링 과정에서 이 트리를 분석하여 어떤 파일이 어떤 파일을 참조하고 있는지 파악하고, 최종 번들 파일을 만드는 데 사용함.

### 모듈 의존성 트리가 필요한 이유

1. 최적화된 번들링
   어떤 모듈이 실제로 사용되는지 파악하여 필요 없는 모듈 제거(Tree Shaking) 가능함.

2. 코드 분할(Code Splitting)
   동적 임포트(import()) 등을 활용해 의존성 트리를 분리함으로써 초기 로딩 속도를 개선할 수 있음.

3. 사이클 탐지
   의존성 트리를 분석하면 순환 참조(circular dependency) 여부도 확인 가능함.

4. 변경 전파(Hot Reload 등)
   특정 파일이 변경되었을 때, 어떤 모듈까지 영향을 미치는지 추적할 수 있음.
